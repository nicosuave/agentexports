use maud::{html, PreEscaped, DOCTYPE};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use worker::*;

const MAX_BLOB_SIZE: usize = 10 * 1024 * 1024; // 10MB

// R2 metrics types
#[derive(Serialize)]
struct R2MetricsDataPoint {
    date: String,
    objects: u64,
    storage_bytes: u64,
}

#[derive(Deserialize)]
struct GraphQLResponse {
    data: Option<GraphQLData>,
    errors: Option<Vec<GraphQLError>>,
}

#[derive(Deserialize)]
struct GraphQLError {
    #[allow(dead_code)]
    message: String,
}

#[derive(Deserialize)]
struct GraphQLData {
    viewer: GraphQLViewer,
}

#[derive(Deserialize)]
struct GraphQLViewer {
    accounts: Vec<GraphQLAccount>,
}

#[derive(Deserialize)]
struct GraphQLAccount {
    #[serde(rename = "r2StorageAdaptiveGroups")]
    r2_storage_adaptive_groups: Vec<R2StorageGroup>,
}

#[derive(Deserialize)]
struct R2StorageGroup {
    dimensions: R2Dimensions,
    max: R2Max,
}

#[derive(Deserialize)]
struct R2Dimensions {
    datetime: String,
}

#[derive(Deserialize)]
struct R2Max {
    #[serde(rename = "payloadSize")]
    payload_size: u64,
    #[serde(rename = "objectCount")]
    object_count: u64,
}

// Embedded OG images (generated by scripts/generate-og.ts)
const OG_HOMEPAGE: &[u8] = include_bytes!("../static/og-homepage.png");
const OG_VIEWER: &[u8] = include_bytes!("../static/og-viewer.png");

// TTL tiers: letter prefix -> (R2 prefix, days)
// Letters chosen outside hex range (g-n) for easy parsing
fn ttl_prefix_to_path(c: char) -> Option<(&'static str, u64)> {
    match c {
        'g' => Some(("30d", 30)),
        'h' => Some(("60d", 60)),
        'j' => Some(("90d", 90)),
        'k' => Some(("180d", 180)),
        'm' => Some(("365d", 365)),
        'n' => Some(("forever", 0)), // 0 = no expiration
        _ => None,
    }
}

fn ttl_days_to_prefix(days: u64) -> char {
    match days {
        0..=30 => 'g',
        31..=60 => 'h',
        61..=90 => 'j',
        91..=180 => 'k',
        181..=365 => 'm',
        _ => 'n', // forever
    }
}

#[event(fetch)]
async fn main(req: Request, env: Env, _ctx: Context) -> Result<Response> {
    console_error_panic_hook::set_once();

    let router = Router::new();

    router
        .get_async("/", handle_homepage)
        .get_async("/api/metrics", handle_metrics)
        .get("/setup", |_, _| {
            let mut response = Response::ok(setup_script())?;
            response.headers_mut().set("Content-Type", "text/plain")?;
            Ok(response)
        })
        .get("/og/homepage.png", |_, _| serve_png(OG_HOMEPAGE))
        .get("/og/viewer.png", |_, _| serve_png(OG_VIEWER))
        .post_async("/upload", handle_upload)
        .get_async("/v/:id", handle_viewer)
        .get_async("/g/:gist_id", handle_gist_viewer)
        .get_async("/blob/:id", handle_blob)
        .delete_async("/blob/:id", handle_delete)
        .options_async("/upload", handle_cors_preflight)
        .options_async("/blob/:id", handle_cors_preflight)
        .run(req, env)
        .await
}

fn cors_headers() -> Headers {
    let headers = Headers::new();
    let _ = headers.set("Access-Control-Allow-Origin", "*");
    let _ = headers.set("Access-Control-Allow-Methods", "GET, POST, DELETE, OPTIONS");
    let _ = headers.set(
        "Access-Control-Allow-Headers",
        "Content-Type, X-Delete-Token, X-TTL-Days",
    );
    headers
}

fn serve_png(data: &[u8]) -> Result<Response> {
    let mut response = Response::from_bytes(data.to_vec())?;
    response.headers_mut().set("Content-Type", "image/png")?;
    response
        .headers_mut()
        .set("Cache-Control", "public, max-age=604800")?; // 1 week
    Ok(response)
}

fn with_cors(mut response: Response) -> Result<Response> {
    let cors = cors_headers();
    for (key, value) in cors.entries() {
        response.headers_mut().set(&key, &value)?;
    }
    Ok(response)
}

fn generate_hash(data: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(data);
    let hash = hasher.finalize();
    hex::encode(&hash[..8])
}

// Parse ID into (r2_path, hash, ttl_days)
// ID format: {ttl_prefix}{16 hex chars} = 17 chars total
// e.g., "gabc123def456789" where 'g' = 30d TTL
fn parse_id(id: &str) -> Option<(String, String, u64)> {
    if id.len() != 17 {
        return None;
    }
    let prefix = id.chars().next()?;
    let (r2_prefix, ttl_days) = ttl_prefix_to_path(prefix)?;
    let hash = &id[1..];
    if !hash.chars().all(|c| c.is_ascii_hexdigit()) {
        return None;
    }
    Some((
        format!("{}/{}", r2_prefix, hash),
        hash.to_string(),
        ttl_days,
    ))
}

fn current_timestamp() -> u64 {
    js_sys::Date::now() as u64 / 1000
}

async fn handle_upload(mut req: Request, ctx: RouteContext<()>) -> Result<Response> {
    // Size check
    if let Some(len) = req.headers().get("content-length")? {
        if let Ok(size) = len.parse::<usize>() {
            if size > MAX_BLOB_SIZE {
                return with_cors(Response::error("Blob too large", 413)?);
            }
        }
    }

    // Get delete token from header (required for delete auth)
    // This is separate from the encryption key - only uploader has it
    let delete_token = req.headers().get("X-Delete-Token")?.unwrap_or_default();
    if delete_token.is_empty() || delete_token.len() != 64 {
        return with_cors(Response::error(
            "Missing or invalid X-Delete-Token header",
            400,
        )?);
    }

    // Get TTL from header (default 30 days)
    let ttl_days: u64 = req
        .headers()
        .get("X-TTL-Days")?
        .and_then(|s| s.parse().ok())
        .unwrap_or(30);

    // Check against MAX_TTL_DAYS if configured
    if let Ok(max_ttl) = ctx.env.var("MAX_TTL_DAYS") {
        if let Ok(max_days) = max_ttl.to_string().parse::<u64>() {
            // TTL > 365 means "forever", which exceeds any finite max
            // TTL 0 also means forever in some contexts
            let effective_ttl = if ttl_days > 365 { u64::MAX } else { ttl_days };
            if effective_ttl > max_days {
                return with_cors(Response::error(
                    format!("TTL exceeds maximum allowed ({} days)", max_days),
                    400,
                )?);
            }
        }
    }

    let body = req.bytes().await?;
    if body.len() > MAX_BLOB_SIZE {
        return with_cors(Response::error("Blob too large", 413)?);
    }
    if body.is_empty() {
        return with_cors(Response::error("Empty body", 400)?);
    }

    // Generate hash and prefixed ID
    let hash = generate_hash(&body);
    let ttl_prefix = ttl_days_to_prefix(ttl_days);
    let id = format!("{}{}", ttl_prefix, hash);

    // Determine R2 path from TTL
    let (r2_prefix, actual_ttl) = ttl_prefix_to_path(ttl_prefix).unwrap();
    let r2_path = format!("{}/{}", r2_prefix, hash);

    let bucket = ctx.env.bucket("TRANSCRIPTS")?;
    let uploaded_at = current_timestamp();
    let expires_at = if actual_ttl > 0 {
        uploaded_at + (actual_ttl * 24 * 60 * 60)
    } else {
        0 // forever
    };

    // Store with metadata
    let mut metadata = std::collections::HashMap::new();
    metadata.insert("uploaded_at".to_string(), uploaded_at.to_string());
    metadata.insert("delete_token".to_string(), delete_token);
    bucket
        .put(&r2_path, body)
        .custom_metadata(metadata)
        .execute()
        .await?;

    let response_body = serde_json::json!({
        "id": id,
        "expires_at": expires_at
    });
    with_cors(Response::from_json(&response_body)?)
}

async fn handle_blob(_req: Request, ctx: RouteContext<()>) -> Result<Response> {
    let id = ctx.param("id").unwrap();

    // Parse ID to get R2 path
    let (r2_path, _, _) = match parse_id(id) {
        Some(parsed) => parsed,
        None => return with_cors(Response::error("Invalid ID", 400)?),
    };

    let bucket = ctx.env.bucket("TRANSCRIPTS")?;

    // R2 lifecycle rules handle expiration automatically
    match bucket.get(&r2_path).execute().await? {
        Some(object) => {
            let body = object.body().ok_or_else(|| Error::from("No body"))?;
            let bytes = body.bytes().await?;

            let headers = Headers::new();
            headers.set("Content-Type", "application/octet-stream")?;
            headers.set("Cache-Control", "public, max-age=86400")?;

            let mut response = Response::from_bytes(bytes)?;
            *response.headers_mut() = headers;
            with_cors(response)
        }
        None => with_cors(Response::error("Not found", 404)?),
    }
}

async fn handle_viewer(_req: Request, ctx: RouteContext<()>) -> Result<Response> {
    let id = ctx.param("id").unwrap();

    // Parse ID to get R2 path
    let (r2_path, _, _) = match parse_id(id) {
        Some(parsed) => parsed,
        None => return Response::error("Invalid ID", 400),
    };

    // Check blob exists (lifecycle rules handle expiration)
    let bucket = ctx.env.bucket("TRANSCRIPTS")?;
    if bucket.head(&r2_path).await?.is_none() {
        return Response::error("Not found", 404);
    }

    let html = viewer_html(id);
    let mut response = Response::from_html(html)?;

    response.headers_mut().set(
        "Content-Security-Policy",
        "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; frame-src 'self' blob:",
    )?;
    response
        .headers_mut()
        .set("X-Content-Type-Options", "nosniff")?;

    Ok(response)
}

async fn handle_gist_viewer(_req: Request, ctx: RouteContext<()>) -> Result<Response> {
    let gist_id = ctx.param("gist_id").unwrap();

    // Validate gist ID format (should be hex string)
    if !gist_id.chars().all(|c| c.is_ascii_hexdigit()) || gist_id.len() < 20 {
        return Response::error("Invalid gist ID", 400);
    }

    // Return lightweight HTML shell - browser fetches gist content directly
    let html = gist_viewer_html(gist_id);
    let mut response = Response::from_html(html)?;

    response.headers_mut().set(
        "Content-Security-Policy",
        "default-src 'self' https://api.github.com https://gist.githubusercontent.com; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; frame-src 'self' blob:; connect-src 'self' https://api.github.com https://gist.githubusercontent.com",
    )?;
    response
        .headers_mut()
        .set("X-Content-Type-Options", "nosniff")?;
    // Cache the shell for longer since it doesn't contain content
    response
        .headers_mut()
        .set("Cache-Control", "public, max-age=3600")?;

    Ok(response)
}

async fn handle_delete(req: Request, ctx: RouteContext<()>) -> Result<Response> {
    let id = ctx.param("id").unwrap();

    // Parse ID to get R2 path
    let (r2_path, _, _) = match parse_id(id) {
        Some(parsed) => parsed,
        None => return with_cors(Response::error("Invalid ID", 400)?),
    };

    // Get delete token from header
    let delete_token = req.headers().get("X-Delete-Token")?.unwrap_or_default();
    if delete_token.is_empty() {
        return with_cors(Response::error("Missing X-Delete-Token header", 401)?);
    }

    let bucket = ctx.env.bucket("TRANSCRIPTS")?;

    // Check blob exists and verify delete token
    match bucket.head(&r2_path).await? {
        Some(object) => {
            let stored_token = object
                .custom_metadata()
                .ok()
                .and_then(|m| m.get("delete_token").cloned())
                .unwrap_or_default();

            if stored_token.is_empty() {
                // Legacy blob without delete_token - can't be deleted via API
                return with_cors(Response::error("Blob predates delete support", 403)?);
            }

            if stored_token != delete_token {
                return with_cors(Response::error("Invalid delete token", 401)?);
            }

            // Delete the blob
            bucket.delete(&r2_path).await?;
            with_cors(Response::empty()?.with_status(204))
        }
        None => with_cors(Response::error("Not found", 404)?),
    }
}

async fn handle_cors_preflight(_req: Request, _ctx: RouteContext<()>) -> Result<Response> {
    let mut response = Response::empty()?;
    *response.headers_mut() = cors_headers();
    response
        .headers_mut()
        .set("Access-Control-Max-Age", "86400")?;
    Ok(response)
}

async fn handle_homepage(_req: Request, _ctx: RouteContext<()>) -> Result<Response> {
    Response::from_html(homepage_html())
}

async fn handle_metrics(_req: Request, ctx: RouteContext<()>) -> Result<Response> {
    let metrics_json = match (ctx.secret("CLOUDFLARE_API_TOKEN"), ctx.secret("R2_ACCOUNT_ID")) {
        (Ok(api_token), Ok(account_id)) => {
            fetch_r2_metrics(&api_token.to_string(), &account_id.to_string()).await
        }
        _ => None,
    };

    match metrics_json {
        Some(json) => {
            let mut response = Response::ok(json)?;
            response.headers_mut().set("Content-Type", "application/json")?;
            response.headers_mut().set("Cache-Control", "public, max-age=300")?; // 5 min cache
            Ok(response)
        }
        None => Response::error("Metrics not configured", 404),
    }
}

async fn fetch_r2_metrics(api_token: &str, account_id: &str) -> Option<String> {
    // Query last 30 days
    let now = js_sys::Date::new_0();
    let end_ms = now.get_time();
    let start_ms = end_ms - (30.0 * 24.0 * 60.0 * 60.0 * 1000.0);

    let end_date = js_sys::Date::new(&wasm_bindgen::JsValue::from_f64(end_ms));
    let start_date = js_sys::Date::new(&wasm_bindgen::JsValue::from_f64(start_ms));

    let end_iso = end_date.to_iso_string().as_string()?;
    let start_iso = start_date.to_iso_string().as_string()?;

    let bucket_name = "agent-exports";

    let graphql_query = r#"
        query R2Storage($accountTag: String!, $start: Time!, $end: Time!, $bucket: String!) {
            viewer {
                accounts(filter: { accountTag: $accountTag }) {
                    r2StorageAdaptiveGroups(
                        limit: 10000
                        filter: { datetime_geq: $start, datetime_leq: $end, bucketName: $bucket }
                        orderBy: [datetime_ASC]
                    ) {
                        dimensions { datetime }
                        max { payloadSize objectCount }
                    }
                }
            }
        }
    "#;

    let payload = serde_json::json!({
        "query": graphql_query,
        "variables": {
            "accountTag": account_id,
            "start": start_iso,
            "end": end_iso,
            "bucket": bucket_name
        }
    });

    let headers = Headers::new();
    headers.set("Content-Type", "application/json").ok()?;
    headers.set("Authorization", &format!("Bearer {}", api_token)).ok()?;

    let mut init = RequestInit::new();
    init.with_method(Method::Post);
    init.with_headers(headers);
    init.with_body(Some(wasm_bindgen::JsValue::from_str(
        &serde_json::to_string(&payload).ok()?,
    )));

    let request = Request::new_with_init("https://api.cloudflare.com/client/v4/graphql", &init).ok()?;
    let mut response = Fetch::Request(request).send().await.ok()?;

    if response.status_code() >= 400 {
        return None;
    }

    let body: GraphQLResponse = response.json().await.ok()?;

    if body.errors.is_some() {
        return None;
    }

    let groups = body
        .data?
        .viewer
        .accounts
        .into_iter()
        .next()?
        .r2_storage_adaptive_groups;

    let data: Vec<R2MetricsDataPoint> = groups
        .into_iter()
        .map(|g| R2MetricsDataPoint {
            date: g.dimensions.datetime,
            objects: g.max.object_count,
            storage_bytes: g.max.payload_size,
        })
        .collect();

    serde_json::to_string(&data).ok()
}

// Shared theme toggle script for both pages
const THEME_SCRIPT: &str = r#"
(function() {
    function getPreferred() {
        const stored = localStorage.getItem('theme');
        if (stored === 'light' || stored === 'dark') return stored;
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    function apply(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        const btn = document.getElementById('theme-toggle');
        if (btn) btn.setAttribute('aria-label', theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode');
    }
    apply(getPreferred());
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        if (!localStorage.getItem('theme')) apply(e.matches ? 'dark' : 'light');
    });
    document.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('theme-toggle');
        if (btn) btn.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme') || getPreferred();
            const next = current === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', next);
            apply(next);
        });
    });
})();
"#;

// Theme toggle button SVG icons
const THEME_TOGGLE_BUTTON: &str = r#"
<button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
    <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="5"/>
        <line x1="12" y1="1" x2="12" y2="3"/>
        <line x1="12" y1="21" x2="12" y2="23"/>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
        <line x1="1" y1="12" x2="3" y2="12"/>
        <line x1="21" y1="12" x2="23" y2="12"/>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
    </svg>
    <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
    </svg>
</button>
"#;

// Theme toggle CSS (shared)
const THEME_TOGGLE_CSS: &str = r#"
.theme-toggle {
    position: fixed;
    top: 16px;
    right: 16px;
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px;
    cursor: pointer;
    color: var(--text-secondary);
    transition: color 0.15s, border-color 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
}
.theme-toggle:hover {
    color: var(--text);
    border-color: var(--text-secondary);
}
.theme-toggle svg {
    width: 18px;
    height: 18px;
}
.theme-toggle .icon-sun { display: none; }
.theme-toggle .icon-moon { display: block; }
[data-theme="dark"] .theme-toggle .icon-sun { display: block; }
[data-theme="dark"] .theme-toggle .icon-moon { display: none; }
"#;

fn homepage_html() -> String {
    let metrics_section = r##"
    <h2>Stats</h2>
    <div id="metrics-container" class="metrics-container"><span class="metrics-loading">Loading...</span></div>
    <script>
    (function() {
        fetch('/api/metrics')
            .then(r => r.ok ? r.json() : Promise.reject())
            .then(renderMetrics)
            .catch(() => {
                document.getElementById('metrics-container').innerHTML = '';
            });

        function renderMetrics(points) {
        const container = document.getElementById('metrics-container');
        if (!points || points.length === 0) { container.innerHTML = ''; return; }

        const latest = points[points.length - 1];
        const formatBytes = b => {
            if (b >= 1e9) return (b / 1e9).toFixed(1) + ' GB';
            if (b >= 1e6) return (b / 1e6).toFixed(1) + ' MB';
            if (b >= 1e3) return (b / 1e3).toFixed(1) + ' KB';
            return b + ' B';
        };
        const formatNum = n => n.toLocaleString();
        const formatDate = d => {
            const date = new Date(d);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        };

        container.innerHTML = `
            <div class="metrics-chart">
                <canvas id="chart" width="672" height="80"></canvas>
                <div class="metrics-tooltip" id="tooltip"></div>
            </div>
            <div class="metrics-axis">
                <span>${formatDate(points[0].date)}</span>
                <span>${formatDate(points[points.length - 1].date)}</span>
            </div>
            <div class="metrics-legend">
                <span><span class="legend-line objects"></span>shares</span>
                <span><span class="legend-line storage"></span>storage</span>
            </div>
        `;

        const canvas = document.getElementById('chart');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const w = canvas.width, h = canvas.height;
        const pad = { t: 8, r: 8, b: 8, l: 8 };
        const cw = w - pad.l - pad.r, ch = h - pad.t - pad.b;

        function normalize(vals) {
            const min = Math.min(...vals), max = Math.max(...vals);
            const range = max - min || 1;
            return vals.map(v => (v - min) / range);
        }

        function drawLine(vals, color) {
            const norm = normalize(vals);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            norm.forEach((v, i) => {
                const x = pad.l + (i / (norm.length - 1)) * cw;
                const y = pad.t + ch - v * ch;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        const style = getComputedStyle(document.documentElement);
        drawLine(points.map(p => p.objects), style.getPropertyValue('--chart-primary').trim() || '#0066cc');
        drawLine(points.map(p => p.storage_bytes), style.getPropertyValue('--chart-secondary').trim() || '#888');

        // Hover tooltip
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scaleX;
            const idx = Math.round(((x - pad.l) / cw) * (points.length - 1));
            if (idx >= 0 && idx < points.length) {
                const p = points[idx];
                tooltip.innerHTML = `${formatNum(p.objects)} shares · ${formatBytes(p.storage_bytes)}`;
                tooltip.style.opacity = '1';
                tooltip.style.left = ((x / canvas.width) * 100) + '%';
            }
        });
        canvas.addEventListener('mouseleave', () => {
            tooltip.style.opacity = '0';
        });
        }
    })();
    </script>
"##;
    let metrics_css = r##"
        .metrics-container { margin: 0.5rem 0; position: relative; }
        .metrics-loading { font-size: 13px; color: var(--text-muted); }
        .metrics-chart { border-radius: 4px; padding: 8px 0; position: relative; }
        .metrics-chart canvas { display: block; width: 100%; height: auto; }
        .metrics-tooltip { position: absolute; top: -24px; transform: translateX(-50%); background: var(--tooltip-bg); color: var(--tooltip-text); padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; opacity: 0; transition: opacity 0.15s; pointer-events: none; }
        .metrics-axis { display: flex; justify-content: space-between; font-size: 11px; color: var(--text-muted); padding: 0 8px; }
        .metrics-legend { display: flex; gap: 1.5rem; margin-top: 0.5rem; font-size: 13px; color: var(--text-secondary); }
        .legend-line { display: inline-block; width: 12px; height: 2px; margin-right: 6px; vertical-align: middle; }
        .legend-line.objects { background: var(--chart-primary); }
        .legend-line.storage { background: var(--chart-secondary); }
"##;

    format!(r##"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>agentexport</title>
    <meta name="description" content="Share Claude Code and Codex transcripts. No signup required.">
    <meta property="og:type" content="website">
    <meta property="og:title" content="agentexport">
    <meta property="og:description" content="Share Claude Code and Codex transcripts. No signup required.">
    <meta property="og:url" content="https://agentexports.com">
    <meta property="og:image" content="https://agentexports.com/og/homepage.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="agentexport">
    <meta name="twitter:description" content="Share Claude Code and Codex transcripts. No signup required.">
    <meta name="twitter:image" content="https://agentexports.com/og/homepage.png">
    <script>{theme_script}</script>
    <style>
        :root {{
            --bg: #fff;
            --text: #111;
            --text-secondary: #666;
            --text-muted: #999;
            --code-bg: #f4f4f4;
            --code-bg-hover: #e8e8e8;
            --border: #ddd;
            --link: #0066cc;
            --chart-primary: #0066cc;
            --chart-secondary: #888;
            --tooltip-bg: #333;
            --tooltip-text: #fff;
            --success: #22863a;
        }}
        [data-theme="dark"] {{
            --bg: #0d1117;
            --text: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --code-bg: #161b22;
            --code-bg-hover: #21262d;
            --border: #30363d;
            --link: #58a6ff;
            --chart-primary: #58a6ff;
            --chart-secondary: #6e7681;
            --tooltip-bg: #1f2428;
            --tooltip-text: #e6edf3;
            --success: #3fb950;
        }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 720px;
            margin: 0 auto;
            padding: 48px 24px;
            line-height: 1.6;
            background: var(--bg);
            color: var(--text);
            transition: background 0.15s, color 0.15s;
        }}
        header {{ display: flex; align-items: baseline; gap: 1rem; margin-bottom: 0.25rem; }}
        h1 {{ margin: 0; }}
        header a {{ color: var(--text-secondary); font-size: 0.9rem; }}
        .tagline {{ color: var(--text-secondary); margin-bottom: 0.5rem; }}
        .subtitle {{ color: var(--text-muted); font-size: 0.85rem; margin-bottom: 2rem; }}
        h2 {{ font-size: 1rem; margin-top: 2rem; color: var(--text); }}
        p {{ margin: 0.5rem 0; }}
        code {{ background: var(--code-bg); padding: 0.1em 0.3em; border-radius: 3px; }}
        a {{ color: var(--link); }}
        .install-box {{
            position: relative;
            display: flex;
            align-items: center;
            background: var(--code-bg);
            border-radius: 4px;
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            font-family: monospace;
            cursor: pointer;
            transition: background 0.15s;
        }}
        .install-box:hover {{ background: var(--code-bg-hover); }}
        .install-box code {{
            flex: 1;
            background: none;
            padding: 0;
        }}
        .install-box .copy-icon {{
            width: 18px;
            height: 18px;
            opacity: 0.5;
            transition: opacity 0.15s;
        }}
        .install-box:hover .copy-icon {{ opacity: 0.8; }}
        .tooltip {{
            position: absolute;
            right: 0;
            top: -32px;
            background: var(--tooltip-bg);
            color: var(--tooltip-text);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s;
        }}
        .install-box:hover .tooltip {{ opacity: 1; }}
        .tooltip.copied {{ background: var(--success); }}{metrics_css}{theme_toggle_css}
    </style>
</head>
<body>
    {theme_toggle_button}
    <header>
        <h1>agentexport</h1>
        <a href="/v/nbc6b43907ec5c0f3#EzyQxZQA3hJnwoO7rzJYym0kjIArv4DuPh2asptdEPM">Demo</a>
        <a href="https://github.com/nicosuave/agentexport">GitHub</a>
    </header>
    <p class="tagline">Share Claude Code and Codex transcripts. No signup required.</p>
    <p class="subtitle"><em>Stats below do not include gist-backed exports.</em></p>

    <h2>Install</h2>
    <div class="install-box" onclick="copyCmd(this)">
        <span class="tooltip">Click to copy</span>
        <code>curl -fsSL https://agentexports.com/setup | sh</code>
        <svg class="copy-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
    </div>
    <script>
    function copyCmd(el) {{
        const text = el.querySelector('code').textContent;
        const tip = el.querySelector('.tooltip');
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        tip.textContent = 'Copied to clipboard';
        tip.classList.add('copied');
        setTimeout(() => {{
            tip.textContent = 'Click to copy';
            tip.classList.remove('copied');
        }}, 2000);
    }}
    </script>

    <h2>Usage</h2>
    <p>Run <code>agentexport setup</code> to install the command, then type <code>/agentexport</code> in Claude Code or Codex.</p>

    <h2>How it works</h2>
    <p>Transcripts are compressed and encrypted locally with AES-256-GCM before upload. The server only stores opaque encrypted blobs. Decryption happens entirely in the recipient's browser.</p>

    <h2>Privacy</h2>
    <p>The decryption key lives in the URL fragment (<code>#key</code>) which browsers never send to servers. The server operator cannot read your transcripts. URLs without the correct key will fail to decrypt, showing only garbled data.</p>

    <h2>Expiration</h2>
    <p>Shares auto-expire after 30 days by default. Configure retention with <code>agentexport config set default_ttl 90</code> (supports 30, 60, 90, 180, 365 days).</p>

    <h2>Self-hosting</h2>
    <p>You can deploy your own instance using Cloudflare Workers and R2. See the <a href="https://github.com/nicosuave/agentexport#self-hosting">README</a> for instructions, then run <code>agentexport config set upload_url https://your-domain.com</code>.</p>
{metrics_section}
</body>
</html>
"##, metrics_section = metrics_section, metrics_css = metrics_css, theme_script = THEME_SCRIPT, theme_toggle_css = THEME_TOGGLE_CSS, theme_toggle_button = THEME_TOGGLE_BUTTON)
}

fn setup_script() -> String {
    r##"#!/bin/sh
set -e

REPO="nicosuave/agentexports"
BINARY="agentexport"
INSTALL_DIR="${INSTALL_DIR:-$HOME/.local/bin}"

# Detect OS
OS="$(uname -s)"
case "$OS" in
    Darwin) OS="macos" ;;
    Linux) OS="linux" ;;
    *) echo "Unsupported OS: $OS"; exit 1 ;;
esac

# Detect architecture
ARCH="$(uname -m)"
case "$ARCH" in
    x86_64|amd64) ARCH="x86_64" ;;
    arm64|aarch64) ARCH="arm64" ;;
    *) echo "Unsupported architecture: $ARCH"; exit 1 ;;
esac

# Get latest version
VERSION=$(curl -fsSL "https://api.github.com/repos/$REPO/releases/latest" | grep '"tag_name"' | sed -E 's/.*"v([^"]+)".*/\1/')
if [ -z "$VERSION" ]; then
    echo "Failed to get latest version"
    exit 1
fi

echo "Installing $BINARY v$VERSION for $OS-$ARCH..."

# Download and extract
URL="https://github.com/$REPO/releases/download/v$VERSION/$BINARY-$VERSION-$OS-$ARCH.tar.gz"
TMP_DIR=$(mktemp -d)
trap "rm -rf $TMP_DIR" EXIT

curl -fsSL "$URL" | tar -xz -C "$TMP_DIR"

mkdir -p "$INSTALL_DIR"
mv "$TMP_DIR/$BINARY" "$INSTALL_DIR/"
chmod +x "$INSTALL_DIR/$BINARY"

echo "Installed $BINARY to $INSTALL_DIR/$BINARY"

# Check if ~/.local/bin is in PATH
case ":$PATH:" in
    *":$HOME/.local/bin:"*) ;;
    *)
        echo ""
        echo "Note: $INSTALL_DIR is not in your PATH."
        echo "Add this to your shell config (~/.bashrc, ~/.zshrc, etc.):"
        echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
        ;;
esac

echo ""
echo "Run 'agentexport setup' to configure Claude Code or Codex"
"##.to_string()
}

// CDN URL for marked.js markdown parser
const MARKED_CDN: &str = "https://cdn.jsdelivr.net/npm/marked@15/lib/marked.umd.min.js";

fn gist_viewer_html(gist_id: &str) -> String {
    let og_url = format!("https://agentexports.com/g/{}", gist_id);

    let markup = html! {
        (DOCTYPE)
        html lang="en" {
            head {
                meta charset="UTF-8";
                meta name="viewport" content="width=device-width, initial-scale=1.0";
                title { "Shared Transcript" }
                meta name="description" content="View a shared Claude Code or Codex session transcript.";
                meta property="og:type" content="article";
                meta property="og:title" content="Shared Transcript";
                meta property="og:description" content="View a shared Claude Code or Codex session transcript.";
                meta property="og:url" content=(og_url);
                meta property="og:image" content="https://agentexports.com/og/viewer.png";
                meta name="twitter:card" content="summary_large_image";
                meta name="twitter:title" content="Shared Transcript";
                meta name="twitter:description" content="View a shared Claude Code or Codex session transcript.";
                meta name="twitter:image" content="https://agentexports.com/og/viewer.png";
                // Start fetch immediately in head, before DOM loads
                script { (PreEscaped(gist_prefetch_js(gist_id))) }
                script { (PreEscaped(THEME_SCRIPT)) }
                script src=(MARKED_CDN) {}
                style { (PreEscaped(VIEWER_CSS)) }
            }
            body {
                (PreEscaped(THEME_TOGGLE_BUTTON))
                div #loading class="loading" {
                    div class="spinner" {}
                    p { "Loading..." }
                }
                div #error class="error" style="display:none" {
                    h2 { "Failed to Load" }
                    p #error-message {}
                }
                div #app style="display:none" {
                    header {
                        div class="title-row" {
                            div class="title-left" {
                                h1 #tool-name { "Transcript" }
                                span #model-info class="model" {}
                            }
                            span #shared-at class="date" {}
                        }
                        div class="meta-row" {
                            div class="token-col" {
                                span #token-summary class="token-summary" {}
                                span #token-summary-2 class="token-summary" {}
                            }
                            div class="toggles" {
                                label {
                                    input #show-thinking type="checkbox" checked;
                                    " Show thinking"
                                }
                                label {
                                    input #show-details type="checkbox";
                                    " Show tool calls"
                                }
                            }
                        }
                    }
                    section #messages class="messages hide-details" {}
                    footer {
                        "via "
                        a href="https://agentexports.com" { "agentexports.com" }
                        " · "
                        a href=(format!("https://gist.github.com/{}", gist_id)) { "view raw gist" }
                    }
                }
                script { (PreEscaped(gist_viewer_js())) }
            }
        }
    };
    markup.into_string()
}

// Small script in <head> to start fetch immediately
fn gist_prefetch_js(gist_id: &str) -> String {
    format!(
        r#"window.GIST_ID = "{gist_id}";
window.gistPromise = fetch("https://api.github.com/gists/{gist_id}")
    .then(r => {{ if (!r.ok) throw new Error("Gist not found"); return r.json(); }})
    .then(g => {{
        const files = g.files;
        const file = files["transcript.md"] || files["agentexport.json"] || Object.values(files)[0];
        if (!file) throw new Error("No files in gist");
        window.gistFilename = file.filename;
        return fetch(file.raw_url);
    }})
    .then(r => {{ if (!r.ok) throw new Error("Failed to fetch content"); return r.text(); }});"#,
        gist_id = gist_id
    )
}

fn viewer_html(blob_id: &str) -> String {
    let og_url = format!("https://agentexports.com/v/{}", blob_id);
    let markup = html! {
        (DOCTYPE)
        html lang="en" {
            head {
                meta charset="UTF-8";
                meta name="viewport" content="width=device-width, initial-scale=1.0";
                title { "Shared Transcript" }
                meta name="description" content="View a shared Claude Code or Codex session transcript.";
                meta property="og:type" content="article";
                meta property="og:title" content="Shared Transcript";
                meta property="og:description" content="View a shared Claude Code or Codex session transcript.";
                meta property="og:url" content=(og_url);
                meta property="og:image" content="https://agentexports.com/og/viewer.png";
                meta name="twitter:card" content="summary_large_image";
                meta name="twitter:title" content="Shared Transcript";
                meta name="twitter:description" content="View a shared Claude Code or Codex session transcript.";
                meta name="twitter:image" content="https://agentexports.com/og/viewer.png";
                script { (PreEscaped(THEME_SCRIPT)) }
                script src=(MARKED_CDN) {}
                style { (PreEscaped(VIEWER_CSS)) }
            }
            body {
                (PreEscaped(THEME_TOGGLE_BUTTON))
                div #loading class="loading" {
                    div class="spinner" {}
                    p { "Decrypting..." }
                }
                div #error class="error" style="display:none" {
                    h2 { "Decryption Failed" }
                    p #error-message {}
                }
                div #app style="display:none" {
                    header {
                        div class="title-row" {
                            div class="title-left" {
                                h1 #tool-name { "Transcript" }
                                span #model-info class="model" {}
                            }
                            span #shared-at class="date" {}
                        }
                        div class="meta-row" {
                            div class="token-col" {
                                span #token-summary class="token-summary" {}
                                span #token-summary-2 class="token-summary" {}
                            }
                            div class="toggles" {
                                label {
                                    input #show-thinking type="checkbox" checked;
                                    " Show thinking"
                                }
                                label {
                                    input #show-details type="checkbox";
                                    " Show tool calls"
                                }
                            }
                        }
                    }
                    section #messages class="messages hide-details" {}
                    footer {
                        "via "
                        a href="https://agentexports.com" { "agentexports.com" }
                    }
                }
                script { (PreEscaped(viewer_js(blob_id))) }
            }
        }
    };
    markup.into_string()
}

const VIEWER_CSS: &str = r#"
:root {
    --bg: #fff;
    --text: #111;
    --text-secondary: #666;
    --text-muted: #999;
    --code-bg: #f5f5f5;
    --border: #ddd;
    --link: #0066cc;
    --spinner-track: #eee;
    --spinner-head: #333;
    --error: #c00;
    --thinking-role: #7c3aed;
    --thinking-border: #c4b5fd;
    --thinking-bg: #faf5ff;
    --thinking-text: #444;
}
[data-theme="dark"] {
    --bg: #0d1117;
    --text: #e6edf3;
    --text-secondary: #8b949e;
    --text-muted: #6e7681;
    --code-bg: #161b22;
    --border: #30363d;
    --link: #58a6ff;
    --spinner-track: #30363d;
    --spinner-head: #e6edf3;
    --error: #f85149;
    --thinking-role: #a78bfa;
    --thinking-border: #6d28d9;
    --thinking-bg: #1e1b2e;
    --thinking-text: #c4b5fd;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
    max-width: 720px;
    margin: 0 auto;
    padding: 48px 24px;
    transition: background 0.15s, color 0.15s;
}
.loading, .error {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 60vh;
    text-align: center;
}
.spinner {
    width: 32px; height: 32px;
    border: 3px solid var(--spinner-track);
    border-top-color: var(--spinner-head);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
}
@keyframes spin { to { transform: rotate(360deg); } }
.error { color: var(--error); }
.error h2 { margin-bottom: 0.5rem; }
header { margin-bottom: 32px; }
.title-row { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 8px; }
.title-left { display: flex; align-items: baseline; gap: 12px; }
h1 { font-size: 18px; font-weight: 600; }
.model { font-size: 13px; color: var(--text-secondary); font-family: ui-monospace, monospace; }
.date { font-size: 13px; color: var(--text-secondary); }
.meta-row { display: flex; justify-content: space-between; align-items: flex-start; margin-top: 8px; }
.token-col { display: flex; flex-direction: column; gap: 2px; }
.toggles { font-size: 13px; color: var(--text-secondary); display: flex; flex-direction: column; gap: 4px; white-space: nowrap; flex-shrink: 0; }
.toggles label { cursor: pointer; display: flex; align-items: center; gap: 4px; }
.token-summary { font-size: 13px; color: var(--text-secondary); font-family: ui-monospace, monospace; }
.token-summary:empty { display: none; }
.command { display: flex; align-items: center; gap: 8px; }
.command-label { font-size: 11px; text-transform: uppercase; color: var(--text-muted); font-weight: 500; }
.command-name { font-family: ui-monospace, monospace; font-size: 14px; color: var(--link); }
.messages { margin-top: 24px; }
.msg { padding: 16px 0; }
.msg-header { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 6px; }
.msg-role { font-size: 12px; font-weight: 600; text-transform: uppercase; color: var(--text-secondary); }
.msg-role.user { color: var(--link); }
.msg-role.assistant { color: var(--text); }
.msg-model { font-size: 11px; color: var(--text-muted); font-family: ui-monospace, monospace; }
.msg-content { font-size: 15px; }
.msg-content p { margin: 0.5em 0; }
.msg-content p:first-child { margin-top: 0; }
.msg-content code { background: var(--code-bg); padding: 0.1em 0.3em; border-radius: 3px; font-size: 0.9em; }
.msg-content pre { background: var(--code-bg); padding: 12px; border-radius: 6px; overflow-x: auto; margin: 0.5em 0; }
.msg-content pre code { background: none; padding: 0; }
.msg-content ul, .msg-content ol { margin: 0.5em 0 0.5em 1.5em; padding: 0; }
.msg-content li { margin: 0.25em 0; }
.msg-content h1, .msg-content h2, .msg-content h3 { margin: 1em 0 0.5em; font-size: 1.1em; }
.msg-content table { border-collapse: collapse; margin: 0.5em 0; width: 100%; }
.msg-content th, .msg-content td { border: 1px solid var(--border); padding: 8px 12px; text-align: left; }
.msg-content th { background: var(--code-bg); font-weight: 600; }
.msg.tool, .msg.system { opacity: 0.7; }
.msg.tool .msg-content { font-family: ui-monospace, monospace; font-size: 13px; white-space: pre-wrap; }
.msg.system .msg-content { font-size: 13px; color: var(--text-secondary); border-left: 3px solid var(--border); padding-left: 12px; }
.msg.thinking { opacity: 0.85; }
.msg.thinking .msg-role { color: var(--thinking-role); }
.msg.thinking .msg-content { font-size: 14px; color: var(--thinking-text); border-left: 3px solid var(--thinking-border); padding-left: 12px; background: var(--thinking-bg); margin-left: -12px; padding: 12px; border-radius: 0 6px 6px 0; }
.hide-details .msg.tool, .hide-details .msg.system { display: none; }
.hide-thinking .msg.thinking { display: none; }
.raw { margin-top: 8px; }
.raw summary { font-size: 12px; color: var(--text-secondary); cursor: pointer; }
.raw pre { background: var(--code-bg); padding: 12px; border-radius: 6px; overflow-x: auto; font-size: 12px; margin-top: 8px; max-height: 300px; }
footer { margin-top: 48px; font-size: 14px; color: var(--text-muted); text-align: center; }
footer a { color: var(--text-muted); text-decoration: none; }
footer a:hover { text-decoration: underline; }
.theme-toggle {
    position: fixed;
    top: 16px;
    right: 16px;
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px;
    cursor: pointer;
    color: var(--text-secondary);
    transition: color 0.15s, border-color 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
}
.theme-toggle:hover {
    color: var(--text);
    border-color: var(--text-secondary);
}
.theme-toggle svg {
    width: 18px;
    height: 18px;
}
.theme-toggle .icon-sun { display: none; }
.theme-toggle .icon-moon { display: block; }
[data-theme="dark"] .theme-toggle .icon-sun { display: block; }
[data-theme="dark"] .theme-toggle .icon-moon { display: none; }
"#;

// Shared JS for both encrypted and gist viewers (render, pricing, etc)
// Note: markdown parsing uses marked.js loaded from CDN
const VIEWER_JS_COMMON: &str = r#"
// Parse command messages like <command-message>x</command-message><command-name>/x</command-name>
function parseCommand(text) {
    const msgMatch = text.match(/<command-message>([^<]*)<\/command-message>/);
    const nameMatch = text.match(/<command-name>([^<]*)<\/command-name>/);
    if (nameMatch) {
        return { name: nameMatch[1], message: msgMatch ? msgMatch[1] : null };
    }
    return null;
}

function render(data) {
    document.getElementById('tool-name').textContent = data.tool || 'Transcript';
    document.getElementById('shared-at').textContent = data.shared_at || '';

    // Model display
    const models = data.models || [];
    const modelEl = document.getElementById('model-info');
    if (models.length === 1) {
        modelEl.textContent = models[0];
    } else if (models.length > 1) {
        modelEl.textContent = models.join(' + ');
    }

    const showMultipleModels = models.length > 1;
    const container = document.getElementById('messages');
    container.innerHTML = '';

    for (const msg of data.messages || []) {
        const div = document.createElement('div');
        div.className = 'msg ' + (msg.role || 'event');

        const header = document.createElement('div');
        header.className = 'msg-header';

        const role = document.createElement('span');
        role.className = 'msg-role ' + (msg.role || '');
        role.textContent = msg.role || 'event';
        header.appendChild(role);

        if (showMultipleModels && msg.model) {
            const model = document.createElement('span');
            model.className = 'msg-model';
            model.textContent = msg.model;
            header.appendChild(model);
        }

        div.appendChild(header);

        const content = document.createElement('div');
        content.className = 'msg-content';
        const msgContent = msg.content || '';

        // Check if this is a command message
        const cmd = msg.role === 'user' ? parseCommand(msgContent) : null;
        if (cmd) {
            content.className = 'msg-content command';
            const label = document.createElement('span');
            label.className = 'command-label';
            label.textContent = 'Command';
            content.appendChild(label);
            const name = document.createElement('span');
            name.className = 'command-name';
            name.textContent = cmd.name;
            content.appendChild(name);
        } else if (msg.role === 'tool') {
            content.textContent = msgContent;
        } else {
            content.innerHTML = marked.parse(msgContent);
        }
        div.appendChild(content);

        if (msg.raw) {
            const details = document.createElement('details');
            details.className = 'raw';
            const summary = document.createElement('summary');
            summary.textContent = msg.raw_label || 'Raw';
            details.appendChild(summary);
            const pre = document.createElement('pre');
            pre.textContent = msg.raw;
            details.appendChild(pre);
            div.appendChild(details);
        }

        container.appendChild(div);
    }

    document.getElementById('show-details').addEventListener('change', function() {
        document.getElementById('messages').classList.toggle('hide-details', !this.checked);
    });

    document.getElementById('show-thinking').addEventListener('change', function() {
        document.getElementById('messages').classList.toggle('hide-thinking', !this.checked);
    });

    // Display token summary with cost
    const tokenEl = document.getElementById('token-summary');
    const input = data.total_input_tokens || 0;
    const output = data.total_output_tokens || 0;
    const cacheRead = data.total_cache_read_tokens || 0;
    const cacheCreate = data.total_cache_creation_tokens || 0;

    if (input > 0 || output > 0) {
        const formatNum = n => n >= 1000 ? (n / 1000).toFixed(1) + 'K' : n.toString();
        const row1 = [formatNum(input) + ' in'];
        if (cacheRead > 0) row1.push(formatNum(cacheRead) + ' cache r');
        if (cacheCreate > 0) row1.push(formatNum(cacheCreate) + ' cache w');
        tokenEl.textContent = row1.join(' · ');

        const row2 = [formatNum(output) + ' out'];
        const model = (data.models && data.models[0]) || '';
        const cost = calculateCost(model, input, output, cacheRead, cacheCreate);
        if (cost !== null) {
            row2.push('$' + (cost < 0.01 ? cost.toFixed(4) : cost.toFixed(2)));
        }
        document.getElementById('token-summary-2').textContent = row2.join(' · ');
    }
}

// Claude pricing (input/cache/output are SEPARATE categories)
const CLAUDE_PRICING = {
    'claude-opus-4-5-20251101': { input: 5e-6, output: 25e-6, cacheRead: 0.5e-6, cacheCreate: 6.25e-6 },
    'claude-opus-4-5': { input: 5e-6, output: 25e-6, cacheRead: 0.5e-6, cacheCreate: 6.25e-6 },
    'claude-opus-4-20250514': { input: 15e-6, output: 75e-6, cacheRead: 1.5e-6, cacheCreate: 18.75e-6 },
    'claude-opus-4-1': { input: 15e-6, output: 75e-6, cacheRead: 1.5e-6, cacheCreate: 18.75e-6 },
    'claude-sonnet-4-5-20250929': { input: 3e-6, output: 15e-6, cacheRead: 0.3e-6, cacheCreate: 3.75e-6, threshold: 200000, inputAbove: 6e-6, outputAbove: 22.5e-6, cacheReadAbove: 0.6e-6, cacheCreateAbove: 7.5e-6 },
    'claude-sonnet-4-5': { input: 3e-6, output: 15e-6, cacheRead: 0.3e-6, cacheCreate: 3.75e-6, threshold: 200000, inputAbove: 6e-6, outputAbove: 22.5e-6, cacheReadAbove: 0.6e-6, cacheCreateAbove: 7.5e-6 },
    'claude-sonnet-4-20250514': { input: 3e-6, output: 15e-6, cacheRead: 0.3e-6, cacheCreate: 3.75e-6, threshold: 200000, inputAbove: 6e-6, outputAbove: 22.5e-6, cacheReadAbove: 0.6e-6, cacheCreateAbove: 7.5e-6 },
    'claude-haiku-4-5-20251001': { input: 1e-6, output: 5e-6, cacheRead: 0.1e-6, cacheCreate: 1.25e-6 },
    'claude-haiku-4-5': { input: 1e-6, output: 5e-6, cacheRead: 0.1e-6, cacheCreate: 1.25e-6 },
};

// Codex pricing (input INCLUDES cached, so we subtract)
const CODEX_PRICING = {
    'gpt-5': { input: 1.25e-6, output: 10e-6, cacheRead: 0.125e-6 },
    'gpt-5-codex': { input: 1.25e-6, output: 10e-6, cacheRead: 0.125e-6 },
    'gpt-5.1': { input: 1.25e-6, output: 10e-6, cacheRead: 0.125e-6 },
    'gpt-5.2': { input: 1.75e-6, output: 14e-6, cacheRead: 0.175e-6 },
    'gpt-5.2-codex': { input: 1.75e-6, output: 14e-6, cacheRead: 0.175e-6 },
};

function normalizeClaudeModel(model) {
    if (!model) return '';
    let m = model.toLowerCase().trim();
    m = m.replace(/^anthropic\./, '');
    // Handle format like "something.claude-opus-4-5"
    const lastDot = m.lastIndexOf('.');
    if (lastDot !== -1 && m.includes('claude-')) {
        const tail = m.slice(lastDot + 1);
        if (tail.startsWith('claude-')) m = tail;
    }
    m = m.replace(/-v\d+:\d+$/, ''); // strip -v1:0 suffix
    // Try with date suffix first, then without
    if (CLAUDE_PRICING[m]) return m;
    const noDate = m.replace(/-\d{8}$/, '');
    if (CLAUDE_PRICING[noDate]) return noDate;
    return m;
}

function normalizeCodexModel(model) {
    if (!model) return '';
    let m = model.toLowerCase().trim();
    m = m.replace(/^openai\//, '');
    // Try stripping -codex suffix for lookup
    const noCodex = m.replace(/-codex$/, '');
    if (CODEX_PRICING[noCodex]) return noCodex;
    return m;
}

function tieredCost(tokens, base, above, threshold) {
    if (!threshold || !above) return tokens * base;
    const below = Math.min(tokens, threshold);
    const over = Math.max(0, tokens - threshold);
    return below * base + over * above;
}

function calculateCost(model, input, output, cacheRead, cacheCreate) {
    // Try Claude pricing first
    const claudeKey = normalizeClaudeModel(model);
    const claudePricing = CLAUDE_PRICING[claudeKey];
    if (claudePricing) {
        // Claude: input_tokens is non-cached, all categories are additive
        const p = claudePricing;
        return tieredCost(input, p.input, p.inputAbove, p.threshold)
             + tieredCost(cacheRead, p.cacheRead, p.cacheReadAbove, p.threshold)
             + tieredCost(cacheCreate, p.cacheCreate, p.cacheCreateAbove, p.threshold)
             + tieredCost(output, p.output, p.outputAbove, p.threshold);
    }

    // Try Codex pricing
    const codexKey = normalizeCodexModel(model);
    const codexPricing = CODEX_PRICING[codexKey];
    if (codexPricing) {
        // Codex: input_tokens includes cached, so subtract
        const p = codexPricing;
        const cached = Math.min(cacheRead, input);
        const nonCached = Math.max(0, input - cached);
        return nonCached * p.input + cached * p.cacheRead + output * p.output;
    }

    return null;
}
"#;

fn viewer_js(blob_id: &str) -> String {
    format!(
        r#"
const BLOB_ID = "{blob_id}";

{common}

async function main() {{
    try {{
        const fragment = window.location.hash.slice(1);
        if (!fragment) throw new Error("No decryption key in URL");

        const keyBytes = base64UrlDecode(fragment);
        if (keyBytes.length !== 32) throw new Error("Invalid key length");

        const response = await fetch('/blob/' + BLOB_ID);
        if (response.status === 410) throw new Error("This transcript has expired");
        if (!response.ok) throw new Error('Failed to fetch: ' + response.status);

        const encrypted = await response.arrayBuffer();
        if (encrypted.byteLength < 13) throw new Error("Invalid blob");

        const iv = encrypted.slice(0, 12);
        const ciphertext = encrypted.slice(12);

        const key = await crypto.subtle.importKey("raw", keyBytes, {{ name: "AES-GCM" }}, false, ["decrypt"]);
        const compressed = await crypto.subtle.decrypt({{ name: "AES-GCM", iv }}, key, ciphertext);
        const json = await decompress(new Uint8Array(compressed));
        const data = JSON.parse(json);

        document.getElementById('loading').style.display = 'none';
        document.getElementById('app').style.display = 'block';
        render(data);
    }} catch (err) {{
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'flex';
        document.getElementById('error-message').textContent = err.message;
    }}
}}

function base64UrlDecode(str) {{
    const pad = str.length % 4;
    if (pad) str += '='.repeat(4 - pad);
    str = str.replace(/-/g, '+').replace(/_/g, '/');
    const bin = atob(str);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return bytes;
}}

async function decompress(data) {{
    const ds = new DecompressionStream('gzip');
    const writer = ds.writable.getWriter();
    writer.write(data);
    writer.close();
    const chunks = [];
    const reader = ds.readable.getReader();
    while (true) {{
        const {{ done, value }} = await reader.read();
        if (done) break;
        chunks.push(value);
    }}
    const result = new Uint8Array(chunks.reduce((a, c) => a + c.length, 0));
    let offset = 0;
    for (const chunk of chunks) {{ result.set(chunk, offset); offset += chunk.length; }}
    return new TextDecoder().decode(result);
}}

main();
"#,
        blob_id = blob_id,
        common = VIEWER_JS_COMMON
    )
}

fn gist_viewer_js() -> String {
    format!(
        r#"
{common}

// Gist-specific: Parse markdown transcript into data structure for rendering
function parseMarkdownTranscript(text) {{
    const data = {{ messages: [], tool: 'Claude Code', models: [] }};

    // Extract title (first h1)
    const titleMatch = text.match(/^# (.+)$/m);
    if (titleMatch) data.title = titleMatch[1];

    // Extract metadata line
    const metaMatch = text.match(/^\*([^*]+)\*$/m);
    if (metaMatch) {{
        const parts = metaMatch[1].split(' · ');
        if (parts.length > 0) data.tool = parts[0];
        if (parts.length > 1) data.models = [parts[1]];
        if (parts.length > 2) data.shared_at = parts[2];
    }}

    // Split by message headers (### Role)
    // Note: We use \z for end-of-string since $ matches end-of-line in multiline mode
    // But JS doesn't support \z, so we use a two-pass approach or negative lookahead
    const msgRegex = /^### ([^\n]+)\n\n([\s\S]*?)(?=\n### |\n---|\n\*Input:)/gm;
    let match;
    while ((match = msgRegex.exec(text)) !== null) {{
        const header = match[1];
        let content = match[2].trim();

        // Parse role from header
        let role = 'assistant';
        let model = null;
        if (header.includes('User')) role = 'user';
        else if (header.includes('Tool')) role = 'tool';
        else if (header.includes('Thinking')) role = 'thinking';
        else if (header.includes('System')) role = 'system';

        // Extract model if present
        const modelMatch = header.match(/\(([^)]+)\)/);
        if (modelMatch) model = modelMatch[1];

        // Handle details sections
        let raw = null;
        let rawLabel = null;
        const detailsMatch = content.match(/<details>\s*<summary>([^<]+)<\/summary>\s*```json\s*([\s\S]*?)```\s*<\/details>/);
        if (detailsMatch) {{
            rawLabel = detailsMatch[1];
            raw = detailsMatch[2].trim();
            content = content.replace(detailsMatch[0], '').trim();
        }}

        data.messages.push({{ role, content, model, raw, raw_label: rawLabel }});
    }}

    // Extract token stats from footer
    const statsMatch = text.match(/^\*Input: (\d+) tokens/m);
    if (statsMatch) {{
        const inputMatch = text.match(/Input: (\d+) tokens/);
        const outputMatch = text.match(/Output: (\d+) tokens/);
        const cacheReadMatch = text.match(/Cache read: (\d+) tokens/);
        const cacheCreateMatch = text.match(/Cache write: (\d+) tokens/);
        if (inputMatch) data.total_input_tokens = parseInt(inputMatch[1]);
        if (outputMatch) data.total_output_tokens = parseInt(outputMatch[1]);
        if (cacheReadMatch) data.total_cache_read_tokens = parseInt(cacheReadMatch[1]);
        if (cacheCreateMatch) data.total_cache_creation_tokens = parseInt(cacheCreateMatch[1]);
    }}

    return data;
}}

// Main: wait for prefetch promise from <head>, then render
async function main() {{
    try {{
        const content = await window.gistPromise;
        const filename = window.gistFilename || '';
        const isMarkdown = filename.endsWith('.md');

        let data;
        if (isMarkdown) {{
            data = parseMarkdownTranscript(content);
        }} else {{
            data = JSON.parse(content);
        }}

        document.getElementById('loading').style.display = 'none';
        document.getElementById('app').style.display = 'block';
        render(data);
    }} catch (err) {{
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error').style.display = 'flex';
        document.getElementById('error-message').textContent = err.message;
    }}
}}

main();
"#,
        common = VIEWER_JS_COMMON
    )
}
